---
title: 'Make your own motion illusion (in Python)'
date: 2024-01-05
permalink: /posts/2024/01/blog-post-4/
tags:
  - Visual Illusion 
  - Apparent Motion
  - Python
---

I'm going to show you how to make your own four-stroke apparent motion illusion!

"What on earth is four-stroke apparent motion?" I hear you say. 

It's this mind-melting (and, after staring for a while, potentially stomach-churning!) effect:  

![f1_headache](../../../../images/f1_headache.gif)

What's amazing is that this effect is generated by presenting just two (!) images again and again (so the illusion lasts more than just a few milliseconds &#128526;) and inverting their luminance profiles with each repetition (hence four-stroke, since its essentilly a four-image sequence). Thats all it takes... kinda crazy! 

I won't go into the specifics of why this gives rise to the perception of never-ending motion, but it relates to my [previous post](https://bootstrapbill.github.io/posts/2022/07/blog-post-2/) on motion energy filtering and there are several [interesting](https://www.sciencedirect.com/science/article/pii/S0042698998001916) [papers](https://journals.sagepub.com/doi/abs/10.1068/p150627) on the topic (if you're familiar with motion energy filtering then Figure 1 of the paper by Mather & Murdoch should be rather intuitive!). 

So how can you make your own version of this effect? First you need to go find a gif that contains interesting motion! The one I used for the demo above looked like this: 

![original gif](../../../../images/f1.png)

Then, it turns out that you can open gifs in preview (sorry non-mac users, I'm sure there is a very simple windows equivalent... but I'm not going to google it) to get to the individual frames. Having done so, all you need to do is pick two sequential (or there abouts...) frames from your gif, where there is a lot of interesting motion happening. Export the two frames as images (.tiff is fine), naming the first 'img1' and the second 'img2' (easiest way is to just drag and drop the relevant frame and then rename it). 

(Note, I also desaturated the images in preview... you don't strictly have to do this, but if you don't then be warned that things will look kinda hectic when you invert the image color profiles!)

Now here's the code I used to actually generate the demo (which you can easily run too, so long as you have psychopy installed). 

```
from psychopy import visual, core

#create a window
win = visual.Window(fullscr = False, size = (800,800), units = 'pix', screen = 1)

im1 = visual.ImageStim(win, image='img1', size = 800)
im2 = visual.ImageStim(win, image='img2', size = 800)

for i in range(2):
    
    for i in range(3):
        
        im1.draw()   
        win.flip()
        win.getMovieFrame(buffer='front')
        
    for i in range(3):
        
        im2.draw()   
        win.flip()
        win.getMovieFrame(buffer='front')

    im1.color *= -1 
    im2.color *= -1

win.saveMovieFrames(fileName='f1_headache.gif', fps = 60) # save movie

win.close()
core.quit()

```

There are obviously myriad other ways you can achieve the same ends, but here's the essential steps: 1) You need to load the images, 2) present them for a few frames (I chose 3 arbitrarily, so that the demo wasn't just a rapid flicker), 3) invert the luminance/colour profiles and present them again. Oh and you also need a way of saving the frame buffer with each screen refresh and then stitching the frames together at the end. That's it! 
s
If you've actually bothered to follow these steps and make your demo then please feel free to send it my way - I'd love to see it! 

There are also some interesting follow up ideas which you (or future me!?) might consider playing with. For example, simple edge-detection filtering could be used to find salient edges (essentially as regions of interest) which can then be slightly offset and contrast reversed... like local four-stroke apparent motion sequences within an image. That might be a cool way of making stationary images appear to move in interesting ways? And may make the image look slightly less &#x1f92e;-inducing (since you might not have to contrast reverse everything?). Who knows... 

If you're reading this and have been bothered to implement that, then I guess you now know... so please enlighten me! 
 
![infinite_homer](../../../../images/infinite_homer.gif)
